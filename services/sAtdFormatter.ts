
import { SAtDData, ProjectFile } from '../types';

function formatFileTree(files: ProjectFile[], indent = 0): string {
  let output = '';
  const prefix = '  '.repeat(indent) + 'â€¢ ';
  for (const file of files) {
    output += `${prefix}${file.name}${file.type === 'directory' ? '/' : ''}\n`;
    if (file.type === 'directory' && file.children && file.children.length > 0) {
      output += formatFileTree(file.children, indent + 1);
    }
  }
  return output;
}

function formatFileExcerptsAndAI(files: ProjectFile[], sectionTitle: string, getContent: (file: ProjectFile) => string | null): string {
  let output = '';
  const sections: string[] = [];

  function traverseFiles(fileList: ProjectFile[]) {
    for (const file of fileList) {
      const content = getContent(file);
      if (content) {
        sections.push(`â–¶ ${file.path}\n\n${content}\n`);
      }
      if (file.type === 'directory' && file.children) {
        traverseFiles(file.children);
      }
    }
  }

  traverseFiles(files);

  if (sections.length > 0) {
    output += `${sectionTitle}\n\n`;
    output += sections.join('\n---\n\n'); // Separator between file entries
  }
  return output;
}


export function generateSAtDContent(data: SAtDData): string {
  let content = `[${data.projectName}] - Structured Ai Transfer Document (.sAtd)\n\n`;

  content += `ðŸ§  æ¦‚è¦\n\n${data.overview || 'No overview provided.'}\n\n`;

  content += `ðŸ“ ãƒ•ã‚¡ã‚¤ãƒ«æ§‹æˆ\n\n${formatFileTree(data.fileStructure)}\n`;
  
  // File Excerpts (Text files primarily)
  content += formatFileExcerptsAndAI(
    data.fileStructure,
    'ðŸ“„ å„ãƒ•ã‚¡ã‚¤ãƒ«æŠœç²‹ (Text Files & Configs)',
    (file) => {
      if (file.type === 'file' && file.content && file.content.trim() !== '' && file.content !== 'Error reading file content.') {
        // Special handling for JSON
        if (file.name.endsWith('.json')) {
          try {
            const jsonObj = JSON.parse(file.content);
            return `\`\`\`json\n${JSON.stringify(jsonObj, null, 2)}\n\`\`\``;
          } catch (e) {
            // If not valid JSON, or some other issue, show as plain text
            return `\`\`\`\n${file.content}\n\`\`\``;
          }
        }
        // For other text files, provide a snippet
        const excerpt = file.content.length > 1000 ? file.content.substring(0, 1000) + '\n... (truncated)' : file.content;
        return `\`\`\`${file.name.substring(file.name.lastIndexOf('.') + 1) || 'text'}\n${excerpt}\n\`\`\``;
      }
      return null; // No excerpt for this file type or if content is empty/error
    }
  );
  content += '\n';


  content += `ðŸ’¬ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚»ã‚¯ã‚·ãƒ§ãƒ³\n\n${data.prompts || 'No prompts provided.'}\n\n`;
  content += `ðŸ” ã‚»ãƒƒã‚·ãƒ§ãƒ³è¦ç´„\n\n${data.sessionSummary || 'No session summary provided.'}\n\n`;
  
  let modulesContent = data.modules || 'No module/library information provided.';
  const packageJsonFile = findFileByName(data.fileStructure, 'package.json');
  if (packageJsonFile && packageJsonFile.content) {
    try {
      const pkg = JSON.parse(packageJsonFile.content);
      let extractedModules = 'From package.json:\n';
      if (pkg.dependencies) {
        extractedModules += 'Dependencies:\n' + Object.keys(pkg.dependencies).map(dep => `  - ${dep}: ${pkg.dependencies[dep]}`).join('\n') + '\n';
      }
      if (pkg.devDependencies) {
        extractedModules += 'Dev Dependencies:\n' + Object.keys(pkg.devDependencies).map(dep => `  - ${dep}: ${pkg.devDependencies[dep]}`).join('\n') + '\n';
      }
      if (data.modules && data.modules.trim() !== '') {
         modulesContent = extractedModules + '\nAdditional Modules:\n' + data.modules;
      } else {
        modulesContent = extractedModules;
      }
    } catch (e) {
      console.warn('Could not parse package.json for module list', e);
      modulesContent = 'Found package.json, but could not parse it.\n' + (data.modules || '');
    }
  }
  content += `ðŸ”© ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«/ãƒ©ã‚¤ãƒ–ãƒ©ãƒªç®¡ç†\n\n${modulesContent.trim()}\n\n`;

  // AI Generated Memos
  content += formatFileExcerptsAndAI(
    data.fileStructure,
    'ðŸ“š å¤–éƒ¨ãƒ•ã‚¡ã‚¤ãƒ«è¨€èªžåŒ–ãƒ¡ãƒ¢ï¼ˆAIæŠ½å‡ºå†…å®¹ & QR Codesï¼‰',
    (file) => {
      let aiContent = '';
      if (file.qrDecodedValue) {
        aiContent += `QR Code Decoded: \`${file.qrDecodedValue}\`\n`;
      }
      if (file.aiSummary) {
        aiContent += `AI Summary:\n${file.aiSummary}\n`;
      }
      return aiContent.trim() ? aiContent : null;
    }
  );
  content += '\n';

  content += `\n---\nGenerated by .sAtd Formatter v1`;
  return content;
}

function findFileByName(files: ProjectFile[], fileName: string): ProjectFile | null {
  for (const file of files) {
    if (file.type === 'file' && file.name === fileName) {
      return file;
    }
    if (file.type === 'directory' && file.children) {
      const found = findFileByName(file.children, fileName);
      if (found) return found;
    }
  }
  return null;
}
